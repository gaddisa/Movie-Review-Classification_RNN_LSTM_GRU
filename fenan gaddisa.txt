<?php

namespace App\Livewire\Payment;

use Carbon\Carbon;
use App\Models\User;
use App\Models\Payment;
use Livewire\Component;
use App\Models\EmployeeInfo;
use App\Models\RentAgreement;
use App\Models\PaymentAllocation;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Auth;
use LivewireUI\Modal\ModalComponent;
use App\Notifications\GeneralNotification;

class TenantsPaymentModal extends ModalComponent
{
    public $agreementId;
    public $selectedMonths = [];
    public $totalAmountDue;
    public $amountToPay;
    public $ttnNumber;
    public $paymentDate;
    public $paymentId = null;
    public $allocationId = null;
    public $isEdit = false;

    public $rentAmount;
    public $minimumPayment;

    protected $rules = [
        'ttnNumber' => ['required', 'string', 'max:15', 'regex:/^[a-zA-Z0-9]+$/'],
        'paymentDate' => 'required|date',
        'amountToPay' => 'required|numeric|min:0',
    ];

    public function mount($agreementId, $selectedMonths, $totalAmount, $paymentId = null, $allocationId = null)
    {
        $this->agreementId = $agreementId;
        $this->selectedMonths = $selectedMonths;
        $this->totalAmountDue = (float)$totalAmount;
        $this->paymentDate = now()->format('Y-m-d');
        $this->amountToPay = (float)$totalAmount;
        $this->paymentId = $paymentId;
        $this->allocationId = $allocationId;
        $this->isEdit = !is_null($paymentId);

        $this->initializePaymentData();
    }

    protected function initializePaymentData()
    {
        try {
            DB::beginTransaction();

            $agreement = RentAgreement::with('tenant')->findOrFail($this->agreementId);
            $currentEmployee = EmployeeInfo::where('user_id', auth()->id())->firstOrFail();

            $this->verifyTenantOwnership($agreement, $currentEmployee);

            $this->rentAmount = (float)$agreement->rent_amount;

            if ($this->isEdit) {
                $this->loadExistingPayment();
            }

            $this->calculateMinimumPayment();

            DB::commit();
        } catch (\Exception $e) {
            DB::rollBack();
            $this->handleError('Payment initialization failed', $e);
            $this->closeModal();
        }
    }

    protected function verifyTenantOwnership($agreement, $employee)
    {
        if ($agreement->tenant_id != $employee->id) {
            abort(403, 'You are not authorized to access this agreement');
        }

        if ($this->isEdit) {
            $payment = Payment::findOrFail($this->paymentId);
            if ($payment->created_by != auth()->id()) {
                abort(403, 'You can only edit your own payments');
            }
        }
    }

    protected function loadExistingPayment()
    {
        $payment = Payment::findOrFail($this->paymentId);
        $this->ttnNumber = $payment->ttn_number;
        $this->paymentDate = $payment->payment_date_gregorian->format('Y-m-d');
        $this->amountToPay = (float)$payment->total_amount;
    }

    protected function calculateMinimumPayment()
    {
        $monthsWithPenalty = array_filter($this->selectedMonths, function ($month) {
            return $this->calculatePenalty($month['year'], $month['month'], $this->rentAmount) > 0;
        });

        // Calculate total rent for penalized months
        $totalRent = count($monthsWithPenths) * $this->rentAmount;
        
        // Calculate total penalty
        $totalPenalty = 0;
        foreach ($monthsWithPenalty as $month) {
            $totalPenalty += $this->calculatePenalty($month['year'], $month['month'], $this->rentAmount);
        }
        
        $this->minimumPayment = $totalRent + $totalPenalty;

        $this->rules['amountToPay'] = [
            'required',
            'numeric',
            'min:' . $this->minimumPayment,
            'max:' . $this->totalAmountDue
        ];
    }

    protected function calculatePenalty($year, $month, $rentAmount)
    {
        $monthDate = Carbon::create($year, $month, 1)->endOfMonth();
        $diffInMonths = $monthDate->diffInMonths(now());
        return $diffInMonths >= 3 ? $rentAmount * 0.10 : 0;
    }

    protected function processPaymentAllocations(Payment $payment)
    {
        $remainingAmount = $this->amountToPay;

        // Sort months chronologically (oldest first)
        usort($this->selectedMonths, function ($a, $b) {
            $dateA = Carbon::create($a['year'], $a['month'], 1);
            $dateB = Carbon::create($b['year'], $b['month'], 1);
            return $dateA->gt($dateB) ? 1 : -1;
        });

        foreach ($this->selectedMonths as $month) {
            if ($remainingAmount <= 0) break;

            $penalty = $this->calculatePenalty($month['year'], $month['month'], $this->rentAmount);
            $totalForMonth = $this->rentAmount + $penalty;
            $amountToAllocate = min($totalForMonth, $remainingAmount);

            PaymentAllocation::create([
                'payment_id' => $payment->id,
                'agreement_id' => $this->agreementId,
                'year_gregorian' => $month['year'],
                'month_gregorian' => $month['month'],
                'penalty_amount' => $penalty,
                'rent_amount' => $this->rentAmount,
                'total_for_the_month' => $totalForMonth,
                'amount_paid' => $amountToAllocate,
                'status' => 'pending',
            ]);

            $remainingAmount -= $amountToAllocate;
        }
    }

    // ... [rest of the methods remain exactly the same as in your original code]
    // Keep all other methods exactly as they were in your original component
    // including submitPayment, updateExistingPayment, createNewPayment, etc.
}
