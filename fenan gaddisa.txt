<?php

namespace App\Models;

use App\Models\Presenters\UserPresenter;
use App\Models\Traits\HasHashedMediaTrait;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Support\Facades\Auth;
use Spatie\MediaLibrary\HasMedia;
use Spatie\Permission\Traits\HasRoles;
use Illuminate\Support\Str;
use RealRashid\SweetAlert\Facades\Alert;

use Lab404\Impersonate\Models\Impersonate;


class User extends Authenticatable implements HasMedia, MustVerifyEmail
{
    use HasFactory;
    use HasHashedMediaTrait;
    use HasRoles;
    use Notifiable;
    use SoftDeletes;
    use UserPresenter;
    use Notifiable;
    use Impersonate;


    protected $guarded = [
        'id',
        'updated_at',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'date_of_birth' => 'datetime',
            'last_login' => 'datetime',
            'deleted_at' => 'datetime',
            'social_profiles' => 'array',
        ];
    }

    /**
     * Boot the model.
     *
     * Register the model's event listeners.
     *
     * @return void
     */


    protected static function boot()
    {
        parent::boot();

        static::creating(function ($model) {
            $model->created_by = Auth::id();
            if (empty($model->uuid)) {
                $model->uuid = (string) Str::uuid();
            }
        });

        static::updating(function ($user) {
            $user->updated_by = Auth::id();

            // Super Admin protection
            if ($user->id === 1 && ($user->isDirty('roles') || $user->isDirty('permissions'))) {
                Alert::toast('Super Admin permissions are locked', 'error');
                abort(403, 'Super Admin permissions are locked');
            }

            // Self-assignment protection
            if ($user->id === Auth::id() && ($user->isDirty('roles') || $user->isDirty('permissions'))) {
                Alert::toast('You cannot modify your own permissions', 'error');
                abort(403, 'You cannot modify your own permissions');
            }
        });

        static::saving(function ($model) {
            $model->updated_by = Auth::id();
        });

        static::deleting(function ($model) {
            $model->deleted_by = Auth::id();
            $model->save();
        });
    }
    /**
     * Retrieve the providers associated with the user.
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function providers()
    {
        return $this->hasMany('App\Models\UserProvider');
    }

    /**
     * Get the list of users related to the current User.
     */
    public function getRolesListAttribute()
    {
        return array_map('intval', $this->roles->pluck('id')->toArray());
    }

    /**
     * Increment tasks when assigned
     */
    public function assignTask()
    {
        $this->increment('tasks_assigned');
        $this->increment('tasks_in_progress');
    }


    /**
     * Mark a task as completed
     */
    public function completeTask($isOverdue = false)
    {
        $this->decrement('tasks_in_progress');
        $this->increment('tasks_completed');

        if ($isOverdue) {
            $this->increment('overdue_completed');
        }
    }

    /**
     * Cancel a task
     */
    public function cancelTask()
    {
        $this->decrement('tasks_in_progress');
        $this->increment('tasks_cancelled');
    }
    //cancel due to conflict of interest
    public function cancelForConflict()
    {
        $this->decrement('tasks_assigned');
        $this->decrement('tasks_in_progress');
    }


    // Relationship: User has one EmployeeInfo
    public function employeeInfo()
    {
        return $this->hasOne(EmployeeInfo::class, 'user_id', 'id');
    }

    // Only admins/cashiers can impersonate
    public function canImpersonate(): bool
    {
        return $this->hasAnyRole(['super admin', 'admin', 'cashier']);
    }

    // Only tenants can be impersonated
    public function canBeImpersonated(): bool
    {
        return $this->hasRole('tenant');
    }
}
