Generic notification


<?php

namespace App\Notifications;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;

class GeneralNotification extends Notification implements ShouldQueue
{
    use Queueable;

    protected $title;
    protected $message;
    protected $module;
    protected $type;
    protected $icon;
    protected $urlBackend;
    protected $urlFrontend;

    public function __construct(array $data)
    {
        $this->title = $data['title'] ?? 'Notification';
        $this->message = $data['message'] ?? '';
        $this->module = $data['module'] ?? 'General';
        $this->type = $data['type'] ?? 'info';
        $this->icon = $data['icon'] ?? 'fas fa-bell';
        $this->urlBackend = $data['url_backend'] ?? route('backend.dashboard');
        $this->urlFrontend = $data['url_frontend'] ?? '';
    }

    public function via($notifiable)
    {
        return ['database'];
    }

    public function toDatabase($notifiable)
    {
        return [
            'title' => $this->title,
            'text' => $this->message,
            'module' => $this->module,
            'type' => $this->type,
            'icon' => $this->icon,
            'url_backend' => $this->urlBackend,
            'url_frontend' => $this->urlFrontend,
        ];
    }
}

//end generic


//tenants payment modal
<?php

namespace App\Livewire\Payment;

use Carbon\Carbon;
use App\Models\User;
use App\Models\Payment;
use Livewire\Component;
use App\Models\EmployeeInfo;
use App\Models\RentAgreement;
use App\Models\PaymentAllocation;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Auth;
use LivewireUI\Modal\ModalComponent;
use App\Notifications\GeneralNotification;

class TenantsPaymentModal extends ModalComponent
{
    public $agreementId;
    public $selectedMonths = [];
    public $totalAmountDue;
    public $amountToPay;
    public $ttnNumber;
    public $paymentDate;
    public $paymentId = null;
    public $allocationId = null;
    public $isEdit = false;

    public $rentAmount;
    public $minimumPayment;

    protected $rules = [
        'ttnNumber' => ['required', 'string', 'max:15', 'regex:/^[a-zA-Z0-9]+$/'],
        'paymentDate' => 'required|date',
        'amountToPay' => 'required|numeric|min:0',
    ];


    public function mount($agreementId, $selectedMonths, $totalAmount, $paymentId = null, $allocationId = null)
    {
        $this->agreementId = $agreementId;
        $this->selectedMonths = $selectedMonths;
        $this->totalAmountDue = $totalAmount;
        $this->paymentDate = now()->format('Y-m-d');
        $this->amountToPay = $totalAmount;
        $this->paymentId = $paymentId;
        $this->allocationId = $allocationId;
        $this->isEdit = !is_null($paymentId);

        $this->initializePaymentData();
    }

    protected function initializePaymentData()
    {
        try {
            DB::beginTransaction();

            $agreement = RentAgreement::with('tenant')->findOrFail($this->agreementId);
            $currentEmployee = EmployeeInfo::where('user_id', auth()->id())->firstOrFail();

            $this->verifyTenantOwnership($agreement, $currentEmployee);

            $this->rentAmount = $agreement->rent_amount;

            if ($this->isEdit) {
                $this->loadExistingPayment();
            }

            $this->calculateMinimumPayment();

            DB::commit();
        } catch (\Exception $e) {
            DB::rollBack();
            $this->handleError('Payment initialization failed', $e);
            $this->closeModal();
        }
    }

    protected function verifyTenantOwnership($agreement, $employee)
    {
        if ($agreement->tenant_id != $employee->id) {
            abort(403, 'You are not authorized to access this agreement');
        }

        if ($this->isEdit) {
            $payment = Payment::findOrFail($this->paymentId);
            if ($payment->created_by != auth()->id()) {
                abort(403, 'You can only edit your own payments');
            }
        }
    }

    protected function loadExistingPayment()
    {
        $payment = Payment::findOrFail($this->paymentId);
        $this->ttnNumber = $payment->ttn_number;
        $this->paymentDate = $payment->payment_date_gregorian->format('Y-m-d');
        $this->amountToPay = $payment->total_amount;
    }

    protected function calculateMinimumPayment()
    {
        $monthsWithPenalty = array_filter($this->selectedMonths, function ($month) {
            return $this->calculatePenalty($month['year'], $month['month'], $this->rentAmount) > 0;
        });

        $penaltyTotal = array_sum(array_column($monthsWithPenalty, 'total'));
        $this->minimumPayment = $penaltyTotal > 0 ? $penaltyTotal : $this->rentAmount;

        $this->rules['amountToPay'] = [
            'required',
            'numeric',
            'min:' . $this->minimumPayment,
            'max:' . $this->totalAmountDue
        ];
    }

    public function updated($property, $value)
    {
        if ($property === 'amountToPay') {
            $this->validateOnly('amountToPay');
        }
    }

    public function submitPayment()
    {
        $this->validate();

        // Clean TTN only once
        $cleanedTtn = strtoupper(preg_replace('/\s+/', '', $this->ttnNumber));

        // Check uniqueness
        if (Payment::ttnExistsInApproved($cleanedTtn, $this->isEdit ? $this->paymentId : null)) {
            $this->dispatch('showToast', [
                'type' => 'error',
                'message' => 'The TTN is already used in an approved payment.'
            ]);
            return;
        }

        try {
            DB::beginTransaction();

            $agreement = RentAgreement::with('tenant')->findOrFail($this->agreementId);
            $currentEmployee = EmployeeInfo::where('user_id', auth()->id())->firstOrFail();

            $this->verifyTenantOwnership($agreement, $currentEmployee);

            if ($this->isEdit) {
                $payment = $this->updateExistingPayment();
            } else {
                $payment = $this->createNewPayment();
            }

            $this->processPaymentAllocations($payment);

            DB::commit();

            // Notify admins about the payment submission or update
            $this->notifyAdminsAboutPayment($payment, $this->isEdit ? 'updated' : 'submitted');

            $this->dispatch('payment-processed');
            $this->dispatch('showToast', [
                'type' => 'success',
                'message' => 'Payment ' . ($this->isEdit ? 'updated' : 'submitted') . ' successfully!'
            ]);
            $this->closeModal();
        } catch (\Exception $e) {
            DB::rollBack();
            $this->handleError('Payment processing failed', $e);
        }
    }

    protected function updateExistingPayment()
    {
        $payment = Payment::findOrFail($this->paymentId);

        // Clean the TTN: remove all whitespace and convert to uppercase
        $cleanedTtn = strtoupper(preg_replace('/\s+/', '', $this->ttnNumber));
        // Check uniqueness
        if (Payment::ttnExistsInApproved($cleanedTtn, $this->isEdit ? $this->paymentId : null)) {
            $this->dispatch('showToast', [
                'type' => 'error',
                'message' => 'The TTN is already used in an approved payment.'
            ]);
            return;
        }

        $payment->update([
            'ttn_number' => $cleanedTtn,
            'total_amount' => $this->amountToPay,
            'payment_date_gregorian' => $this->paymentDate,
            'status' => 'pending',
            'updated_by' => Auth::id(),
        ]);

        // Delete previous allocations
        PaymentAllocation::where('payment_id', $payment->id)->delete();
        // Notify CEO and Cashiers about payment update
        $this->notifyAdminsAboutPayment($payment, 'updated');
        return $payment;
    }


    protected function createNewPayment()
    {
        // Clean the TTN: remove all whitespace and convert to uppercase
        $cleanedTtn = strtoupper(preg_replace('/\s+/', '', $this->ttnNumber));

        return Payment::create([
            'agreement_id' => $this->agreementId,
            'ttn_number' => $cleanedTtn,
            'total_amount' => $this->amountToPay,
            'payment_date_gregorian' => $this->paymentDate,
            'status' => 'pending',
            'created_by' => Auth::id(),
        ]);

        // Notify CEO and Cashiers about new payment submission
        //$this->notifyAdminsAboutPayment($payment, 'submitted');
    }


    protected function processPaymentAllocations(Payment $payment)
    {
        $remainingAmount = $this->amountToPay;

        foreach ($this->selectedMonths as $month) {
            if ($remainingAmount <= 0) break;

            $penalty = $this->calculatePenalty($month['year'], $month['month'], $this->rentAmount);
            $totalForMonth = $this->rentAmount + $penalty;
            $amountToAllocate = min($totalForMonth, $remainingAmount);

            PaymentAllocation::create([
                'payment_id' => $payment->id,
                'agreement_id' => $this->agreementId,
                'year_gregorian' => $month['year'],
                'month_gregorian' => $month['month'],
                'penalty_amount' => $penalty,
                'rent_amount' => $this->rentAmount,
                'total_for_the_month' => $totalForMonth,
                'amount_paid' => $amountToAllocate,
                'status' => 'pending',
            ]);

            $remainingAmount -= $amountToAllocate;
        }
    }

    protected function calculatePenalty($year, $month, $rentAmount)
    {
        $monthDate = Carbon::create($year, $month, 1)->endOfMonth();
        $diffInMonths = $monthDate->diffInMonths(now());
        return $diffInMonths >= 3 ? $rentAmount * 0.10 : 0;
    }

    protected function handleError(string $context, \Exception $e)
    {
        Log::error($context, [
            'error' => $e->getMessage(),
            'agreement_id' => $this->agreementId,
            'payment_id' => $this->paymentId,
            'user_id' => Auth::id()
        ]);
        $this->dispatch('showToast', [
            'type' => 'error',
            'message' => $e->getMessage()
        ]);
    }

    public static function modalMaxWidth(): string
    {
        return '2xl';
    }

    public function render()
    {
        try {
            $agreement = RentAgreement::with(['tenant', 'room'])->findOrFail($this->agreementId);
            $currentEmployee = EmployeeInfo::where('user_id', auth()->id())->firstOrFail();

            $this->verifyTenantOwnership($agreement, $currentEmployee);

            return view('livewire.payment.tenants-payment-modal', [
                'agreement' => $agreement,
            ]);
        } catch (\Exception $e) {
            $this->handleError('Render failed', $e);
            return view('livewire.payment.tenants-payment-modal', ['agreement' => null]);
        }
    }
    protected function notifyAdminsAboutPayment(Payment $payment, string $action)
    {
        try {
            // Get the tenant directly from the agreement
            $tenant = EmployeeInfo::find($payment->agreement_id);

            $data = [
                'title' => ucfirst($action) . ' Rent Payment',
                'message' => sprintf(
                    '%s %s a rent payment of %s (TTN: %s)',
                    auth()->user()->name,
                    $action,
                    number_format($payment->total_amount, 2),
                    $payment->ttn_number
                ),
                'module' => 'Rent Payment',
                'type' => $action,
                'icon' => 'fas fa-money-bill-wave',
                'url_backend' => route('backend.paymentreports.index'),
                'url_frontend' => '',
            ];

            // Get admin users (CEO, Cashier, Super Admin)
            $admins = User::role(['ceo', 'cashier', 'super admin'])->get();

            foreach ($admins as $admin) {
                $admin->notify(new GeneralNotification($data));
            }
        } catch (\Exception $e) {
            Log::error('Payment notification failed', [
                'payment_id' => $payment->id,
                'error' => $e->getMessage()
            ]);
        }
    }
}

//end tenants

//payment approval
<?php

namespace App\Livewire\PaymentReport;

use App\Models\User;
use App\Models\Payment;
use Livewire\Component;
use App\Models\EmployeeInfo;
use App\Models\PaymentAllocation;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Auth;
use LivewireUI\Modal\ModalComponent;
use App\Notifications\GeneralNotification;

class PaymentApprovalModal extends ModalComponent
{
    public $paymentId;
    public $rejectReason;
    public $approvalAction = 'approve';
    public $payment;
    public $allocations;
    public $showRejectReason = false;
    public $currentUserRole;
    public $canApprove = false;

    protected $rules = [
        'rejectReason' => 'required_if:approvalAction,reject|max:255',
    ];

    public function mount($paymentId)
    {
        $this->paymentId = $paymentId;
        $this->currentUserRole = Auth::user()->roles->first()->name;
        $this->loadPayment();
    }

    protected function loadPayment()
    {
        try {
            $this->payment = Payment::with(['allocations', 'agreement.tenant.user'])->findOrFail($this->paymentId);
            $this->allocations = $this->payment->allocations;

            if (!$this->canAccessPayment()) {
                $this->dispatch('showToast', [
                    'type' => 'error',
                    'message' => 'Unauthorized action.'
                ]);
                $this->closeModal();
                return;
            }

            $this->canApprove = $this->checkApprovalRights();
        } catch (\Exception $e) {
            Log::error('Payment loading failed', [
                'error' => $e->getMessage(),
                'payment_id' => $this->paymentId,
                'user_id' => Auth::id()
            ]);
            $this->dispatch('showToast', [
                'type' => 'error',
                'message' => 'Failed to load payment data'
            ]);
            $this->closeModal();
        }
    }

    protected function canAccessPayment(): bool
    {
        $user = Auth::user();
        $payment = $this->payment;

        if ($user->hasAnyRole(['super admin', 'ceo', 'cashier'])) {
            return true;
        }

        return $payment->created_by === $user->id;
    }

    protected function checkApprovalRights(): bool
    {
        $user = Auth::user();
        $payment = $this->payment;

        if ($payment->status !== 'pending') {
            return false;
        }

        if ($payment->updated_by === $payment->created_by) {
            return $user->hasRole('cashier');
        } else {
            return $user->hasAnyRole(['super admin', 'ceo']);
        }
    }

    public function updatedApprovalAction($value)
    {
        $this->showRejectReason = $value === 'reject';
        if ($value === 'approve') {
            $this->rejectReason = null;
        }
        $this->resetValidation('rejectReason');
    }

    public function submitApproval()
    {
        $this->validate();

        try {
            DB::beginTransaction();

            $user = Auth::user();
            $payment = Payment::findOrFail($this->paymentId);
            $this->verifyApprovalWorkflow($payment, $user);

            if ($this->approvalAction === 'approve') {
                $this->processApproval($payment, $user);
            } else {
                $this->processRejection($payment, $user);
            }

            DB::commit();

            $this->dispatch('payment-approved');
            $this->closeModal();
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('Payment approval failed', [
                'error' => $e->getMessage(),
                'payment_id' => $this->paymentId,
                'user_id' => Auth::id()
            ]);
            $this->dispatch('showToast', [
                'type' => 'error',
                'message' => $e->getMessage()
            ]);
        }
    }

    protected function verifyApprovalWorkflow(Payment $payment, $user)
    {
        if ($payment->status !== 'pending') {
            throw new \Exception('Only pending payments can be approved/rejected');
        }

        if ($payment->updated_by === $payment->created_by) {
            if (!$user->hasRole('cashier')) {
                throw new \Exception('Only cashiers can approve initial submissions');
            }
        } else {
            if (!$user->hasAnyRole(['super admin', 'ceo'])) {
                throw new \Exception('Only administrators can give final approval');
            }
        }
    }

    protected function processApproval(Payment $payment, $user)
    {
        if ($user->hasRole('cashier') && $payment->updated_by === $payment->created_by) {
            // Cashier first approval
            $payment->update(['updated_by' => $user->id]);

            $this->notifyAdmins('cashier_approved', $payment, $user);
            $this->dispatch('showToast', [
                'type' => 'success',
                'message' => 'Payment approved by cashier. Waiting for final approval.'
            ]);
        } elseif ($user->hasAnyRole(['super admin', 'ceo'])) {
            // Final approval


            PaymentAllocation::where('payment_id', $payment->id)
                ->update([
                    'status' => 'approved',
                    'updated_by' => $user->id
                ]);

            $payment->update([
                'status' => 'approved',
                'approved_by' => $user->id,
                'approved_at' => now(),
                'updated_by' => $user->id
            ]);

            $this->notifyCashiers('admin_approved', $payment, $user);
            $this->notifyTenant('approved', $payment, $user);

            $this->dispatch('showToast', [
                'type' => 'success',
                'message' => 'Payment fully approved.'
            ]);
        }
    }

    protected function processRejection(Payment $payment, $user)
    {

        PaymentAllocation::where('payment_id', $payment->id)
            ->update([
                'status' => 'rejected',
                'updated_by' => $user->id,
                'reject_reason' => $this->rejectReason
            ]);

        $payment->update([
            'status' => 'rejected',
            'reject_reason' => $this->rejectReason,
            'updated_by' => $user->id
        ]);

        if ($user->hasRole('cashier')) {
            $this->notifyAdmins('cashier_rejected', $payment, $user);
        } else {
            $this->notifyCashiers('admin_rejected', $payment, $user);
        }

        $this->notifyTenant('rejected', $payment, $user);

        $this->dispatch('showToast', [
            'type' => 'error',
            'message' => 'Payment rejected.'
        ]);
    }

    protected function notifyAdmins(string $action, Payment $payment, $user)
    {
        try {
            $admins = User::role(['super admin', 'ceo'])->get();
            $actionText = str_replace('_', ' ', $action);

            foreach ($admins as $admin) {
                $admin->notify(new GeneralNotification([
                    'title' => 'Payment ' . ucfirst($actionText),
                    'message' => sprintf(
                        '%s %s payment %s (TTN: %s, Amount: %s)',
                        $user->name,
                        $actionText,
                        $payment->id,
                        $payment->ttn_number,
                        number_format($payment->total_amount, 2)
                    ),
                    'module' => 'Payment',
                    'type' => $action,
                    'icon' => 'fas fa-money-bill-wave',
                    'url_backend' => route('backend.paymentreports.index'),
                    'url_frontend' => ''
                ]));
            }
        } catch (\Exception $e) {
            Log::error('Admin notification failed', [
                'error' => $e->getMessage(),
                'payment_id' => $payment->id
            ]);
        }
    }

    protected function notifyCashiers(string $action, Payment $payment, $user)
    {
        try {
            $cashiers = User::role('cashier')->get();
            $actionText = str_replace('_', ' ', $action);

            foreach ($cashiers as $cashier) {
                $cashier->notify(new GeneralNotification([
                    'title' => 'Payment ' . ucfirst($actionText),
                    'message' => sprintf(
                        '%s %s payment %s (TTN: %s, Amount: %s)',
                        $user->name,
                        $actionText,
                        $payment->id,
                        $payment->ttn_number,
                        number_format($payment->total_amount, 2)
                    ),
                    'module' => 'Payment',
                    'type' => $action,
                    'icon' => 'fas fa-money-bill-wave',
                    'url_backend' => route('backend.paymentreports.index'),
                    'url_frontend' => ''
                ]));
            }
        } catch (\Exception $e) {
            Log::error('Cashier notification failed', [
                'error' => $e->getMessage(),
                'payment_id' => $payment->id
            ]);
        }
    }

    protected function notifyTenant(string $action, Payment $payment, $user)
    {
        try {
            $tenantUser = \App\Models\User::find($payment->created_by);

            if (!$tenantUser) {
                Log::warning('Tenant user not found using created_by', [
                    'payment_id' => $payment->id,
                    'created_by' => $payment->created_by,
                ]);
                return;
            }

            $actionText = $action === 'approved' ? 'approved' : 'rejected';
            $reason = $action === 'rejected' ? " Reason: {$payment->reject_reason}" : '';

            $notification = new GeneralNotification([
                'title' => "Payment {$actionText}",
                'message' => sprintf(
                    'Your payment (TTN: %s) of %s has been %s by %s.%s',
                    $payment->ttn_number,
                    number_format($payment->total_amount, 2),
                    $actionText,
                    $user->name,
                    $reason
                ),
                'module' => 'Payment',
                'type' => $action,
                'icon' => $action === 'approved' ? 'fas fa-check-circle' : 'fas fa-times-circle',
                'url_backend' => route('backend.payments.index'),
                'url_frontend' => route('tenant.payments.index'),
            ]);

            $tenantUser->notify($notification);

            Log::info('Notification sent to tenant', [
                'user_id' => $tenantUser->id,
                'notification_class' => get_class($notification),
            ]);
        } catch (\Exception $e) {
            Log::error('Tenant notification failed using created_by', [
                'error' => $e->getMessage(),
                'payment_id' => $payment->id,
                'created_by' => $payment->created_by,
            ]);
        }
    }





    public static function modalMaxWidth(): string
    {
        return '2xl';
    }

    public function render()
    {
        return view('livewire.payment-report.payment-approval-modal', [
            'canApprove' => $this->canApprove
        ]);
    }
}


